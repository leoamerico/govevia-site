#!/usr/bin/env node

import fs from 'node:fs'
import path from 'node:path'

const CHECK_MODE = process.argv.includes('--check')

const repoRoot = process.cwd()
const pkgRoot = path.join(repoRoot, 'packages', 'design-tokens')
const tokensPath = path.join(pkgRoot, 'tokens.json')
const distDir = path.join(pkgRoot, 'dist')
const outCss = path.join(distDir, 'tokens.css')
const outPreset = path.join(distDir, 'tailwind.preset.cjs')
const outManifest = path.join(distDir, 'tokens.manifest.json')
const outRuntimeTs = path.join(distDir, 'tokens.runtime.ts')

function readJson(p) {
  return JSON.parse(fs.readFileSync(p, 'utf8'))
}

function getAt(obj, dottedPath) {
  const parts = dottedPath.split('.')
  let cur = obj
  for (const p of parts) {
    cur = cur?.[p]
  }
  return cur
}

function toCssVarName(tokenPath) {
  // tokenPath: e.g. color.brand.govevia.primary.700
  // desired: --brand-govevia-primary-700-rgb
  const parts = tokenPath.split('.')
  if (parts[0] !== 'color') return `--${parts.join('-')}`

  const scope = parts[1]
  if (!scope) return `--${parts.slice(1).join('-')}`

  if (scope === 'brand') return `--brand-${parts.slice(2).join('-')}-rgb`
  if (scope === 'semantic') return `--semantic-${parts.slice(2).join('-')}-rgb`
  if (scope === 'ui') return `--ui-${parts.slice(2).join('-')}-rgb`

  return `--${parts.slice(1).join('-')}-rgb`
}

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true })
}

function stableStringify(obj) {
  return JSON.stringify(obj, Object.keys(obj).sort(), 2)
}

function flattenTokens(obj, prefix = '') {
  const out = {}
  if (!obj || typeof obj !== 'object') return out

  for (const key of Object.keys(obj).sort()) {
    const val = obj[key]
    const nextPrefix = prefix ? `${prefix}.${key}` : key

    if (val && typeof val === 'object' && !Array.isArray(val)) {
      const isLeaf = 'hex' in val || 'rgb' in val
      if (isLeaf) {
        out[nextPrefix] = {
          ...(typeof val.hex === 'string' ? { hex: val.hex } : {}),
          ...(typeof val.rgb === 'string' ? { rgb: val.rgb } : {})
        }
      } else {
        Object.assign(out, flattenTokens(val, nextPrefix))
      }
    } else {
      out[nextPrefix] = val
    }
  }
  return out
}

function writeFileOrCheck(filePath, content) {
  if (!CHECK_MODE) {
    fs.writeFileSync(filePath, content, 'utf8')
    return
  }
  const current = fs.existsSync(filePath) ? fs.readFileSync(filePath, 'utf8') : ''
  if (current !== content) {
    console.error(`FALHA: ${path.relative(repoRoot, filePath)} está divergente. Rode npm run tokens:build.`)
    process.exit(1)
  }
}

function main() {
  if (!fs.existsSync(tokensPath)) {
    console.error(`ERRO: ${path.relative(repoRoot, tokensPath)} não encontrado`)
    process.exit(1)
  }

  const data = readJson(tokensPath)
  const aliasColors = data?.aliases?.tailwind?.colors
  const aliasRadius = data?.aliases?.tailwind?.radius

  if (!aliasColors || typeof aliasColors !== 'object') {
    console.error('ERRO: tokens.json precisa conter aliases.tailwind.colors')
    process.exit(1)
  }

  // --- tokens.css ---
  const cssLines = []
  cssLines.push('/* AUTO-GENERATED by packages/design-tokens/scripts/build.mjs */')
  cssLines.push(':root {')

  // Emit all aliased colors as CSS vars (RGB triplets)
  const seen = new Set()
  for (const tokenPath of Object.values(aliasColors)) {
    if (typeof tokenPath !== 'string') continue
    if (seen.has(tokenPath)) continue
    seen.add(tokenPath)

    const node = getAt(data.tokens, tokenPath)
    if (!node || typeof node !== 'object' || typeof node.rgb !== 'string') {
      console.error(`ERRO: token ${tokenPath} precisa ter { rgb: "r g b" }`)
      process.exit(1)
    }
    const varName = toCssVarName(tokenPath)
    cssLines.push(`  ${varName}: ${node.rgb};`)
  }

  // radius + icon stroke
  const radius2 = getAt(data.tokens, 'radius.2')
  if (typeof radius2 !== 'string') {
    console.error('ERRO: tokens.radius.2 precisa existir (ex: "8px")')
    process.exit(1)
  }
  cssLines.push(`  --radius-2: ${radius2};`)
  cssLines.push('  --radius-default: var(--radius-2);')

  const iconStrokeBase = getAt(data.tokens, 'icon.stroke.base_at_24')
  if (typeof iconStrokeBase !== 'string') {
    console.error('ERRO: tokens.icon.stroke.base_at_24 precisa existir (ex: "2px")')
    process.exit(1)
  }
  cssLines.push(`  --icon-stroke: ${iconStrokeBase};`) // regra de escala documentada
  cssLines.push('  --icon-stroke-ref-size: 24px;')

  cssLines.push('}')
  cssLines.push('')

  // --- tailwind preset ---
  const tailwindColors = {}
  for (const [twKey, tokenPath] of Object.entries(aliasColors)) {
    const varName = toCssVarName(tokenPath)
    tailwindColors[twKey] = `rgb(var(${varName}) / <alpha-value>)`
  }

  const borderRadius = {}
  if (aliasRadius && typeof aliasRadius === 'object') {
    for (const [k, tokenPath] of Object.entries(aliasRadius)) {
      if (typeof tokenPath !== 'string') continue
      if (tokenPath === 'radius.2') borderRadius[k] = 'var(--radius-2)'
      else borderRadius[k] = `var(--${tokenPath.replace(/\./g, '-')})`
    }
  }

  const presetObj = {
    theme: {
      extend: {
        colors: {
          // Top-level shorthand aliases
          'deep-navy': tailwindColors['deep-navy'],
          // Back-compat: allow nested access for existing code (primary.light, institutional.navy)
          primary: {
            DEFAULT: tailwindColors.primary,
            light: tailwindColors['primary-light'],
            dark: tailwindColors['primary-dark'],
            accent: tailwindColors['primary-accent']
          },
          accent: {
            gold: tailwindColors['accent-gold'],
            copper: tailwindColors['accent-copper']
          },
          institutional: {
            navy: tailwindColors['institutional-navy'],
            graphite: tailwindColors['institutional-graphite'],
            slate: tailwindColors['institutional-slate'],
            silver: tailwindColors['institutional-silver'],
            lightgray: tailwindColors['institutional-lightgray'],
            offwhite: tailwindColors['institutional-offwhite']
          },
          envneo: {
            neutral: {
              900: tailwindColors['envneo-neutral-900']
            }
          },
          semantic: {
            success: tailwindColors.success,
            warning: tailwindColors.warning,
            danger: tailwindColors.danger
          },
          ui: {
            text: {
              primary: tailwindColors['ui-text-primary'],
              muted: tailwindColors['ui-text-muted'],
              inverse: tailwindColors['ui-text-inverse']
            },
            bg: {
              canvas: tailwindColors['ui-bg-canvas'],
              muted: tailwindColors['ui-bg-muted']
            },
            border: {
              subtle: tailwindColors['ui-border-subtle']
            }
          }
        },
        borderRadius: {
          DEFAULT: 'var(--radius-default)',
          md: 'var(--radius-2)',
          ...borderRadius
        },
        fontFamily: {
          sans: ['var(--font-plex-sans)', 'system-ui', 'sans-serif'],
          serif: ['var(--font-plex-serif)', 'ui-serif', 'Georgia', 'serif'],
          mono: ['var(--font-plex-mono)', 'ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono', 'monospace']
        }
      }
    }
  }

  const presetContent = [
    '/* AUTO-GENERATED by packages/design-tokens/scripts/build.mjs */',
    'module.exports = ' + JSON.stringify(presetObj, null, 2),
    ''
  ].join('\n')

  ensureDir(distDir)
  writeFileOrCheck(outCss, cssLines.join('\n'))
  writeFileOrCheck(outPreset, presetContent)

  // --- tokens.manifest.json ---
  const manifest = {
    meta: data.meta,
    flattened: flattenTokens(data.tokens),
    aliases: data.aliases
  }
  const manifestContent = JSON.stringify(manifest, null, 2) + '\n'
  writeFileOrCheck(outManifest, manifestContent)

  // --- tokens.runtime.ts (HEX constants for environments without CSS vars, e.g. next/og) ---
  const runtime = {
    brand: {
      govevia: {
        primary: {
          900: getAt(data.tokens, 'color.brand.govevia.primary.900')?.hex,
          800: getAt(data.tokens, 'color.brand.govevia.primary.800')?.hex,
          700: getAt(data.tokens, 'color.brand.govevia.primary.700')?.hex,
          600: getAt(data.tokens, 'color.brand.govevia.primary.600')?.hex,
          500: getAt(data.tokens, 'color.brand.govevia.primary.500')?.hex
        },
        accent: {
          gold: getAt(data.tokens, 'color.brand.govevia.accent.gold')?.hex,
          copper: getAt(data.tokens, 'color.brand.govevia.accent.copper')?.hex
        }
      },
      institutional: {
        navy: getAt(data.tokens, 'color.brand.institutional.navy')?.hex,
        'deep-navy': getAt(data.tokens, 'color.brand.institutional.deep-navy')?.hex,
        graphite: getAt(data.tokens, 'color.brand.institutional.graphite')?.hex,
        slate: getAt(data.tokens, 'color.brand.institutional.slate')?.hex,
        silver: getAt(data.tokens, 'color.brand.institutional.silver')?.hex,
        lightgray: getAt(data.tokens, 'color.brand.institutional.lightgray')?.hex,
        offwhite: getAt(data.tokens, 'color.brand.institutional.offwhite')?.hex
      },
      envneo: {
        neutral: {
          900: getAt(data.tokens, 'color.brand.envneo.neutral.900')?.hex,
          1000: getAt(data.tokens, 'color.brand.envneo.neutral.1000')?.hex
        }
      }
    },
    semantic: {
      success700: getAt(data.tokens, 'color.semantic.success.700')?.hex,
      warning700: getAt(data.tokens, 'color.semantic.warning.700')?.hex,
      danger700: getAt(data.tokens, 'color.semantic.danger.700')?.hex
    },
    ui: {
      bg: {
        canvas: getAt(data.tokens, 'color.ui.bg.canvas')?.hex,
        muted: getAt(data.tokens, 'color.ui.bg.muted')?.hex
      },
      text: {
        primary: getAt(data.tokens, 'color.ui.text.primary')?.hex,
        muted: getAt(data.tokens, 'color.ui.text.muted')?.hex,
        inverse: getAt(data.tokens, 'color.ui.text.inverse')?.hex
      },
      border: {
        subtle: getAt(data.tokens, 'color.ui.border.subtle')?.hex
      }
    },
    radius2: getAt(data.tokens, 'radius.2'),
  }

  const runtimeTs = [
    '/* AUTO-GENERATED by packages/design-tokens/scripts/build.mjs */',
    'export const TOKENS_RUNTIME = ' + JSON.stringify(runtime, null, 2) + ' as const;',
    ''
  ].join('\n')
  writeFileOrCheck(outRuntimeTs, runtimeTs)

  if (!CHECK_MODE) {
    console.log(
      'OK: design tokens generated:',
      path.relative(repoRoot, outCss),
      path.relative(repoRoot, outPreset),
      path.relative(repoRoot, outManifest),
      path.relative(repoRoot, outRuntimeTs)
    )
  } else {
    console.log('OK: design tokens up-to-date')
  }
}

main()
