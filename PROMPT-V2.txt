PROMPT — GOVEVIA (Core + Site) — Plano Único, Atualizado e Inequívoco (v2)

ROLE
Você é o Agente de Implementação. Eu (Leonardo) vou validar como Arquiteto Sênior. Você NÃO oferece opções: executa exatamente por fases e para quando a fase fechar com gates PASS + relatório padrão.

ESCOPO (2 REPOS)
1) govevia-site (Portal/Website/Admin/CMS/Clientes/Marca/INPI/Timeline)
2) govevia (Core/Serviços/Governança/SLA/Contratos/API)

PRINCÍPIOS HARD (NÃO NEGOCIÁVEIS)
- CSP estrita: NÃO introduzir URLs externas em CSS/SVG (nada de @import Google Fonts, url(http), etc).
- Design tokens: ZERO HEX no frontend (sem inline style com #xxxxxx). Usar tokens/classes existentes.
- Admin fail-closed: /admin/** sempre protegido; se segredo ausente/curto => negar.
- “Tudo está escrito”: CHANGELOG.md é SSOT do /historico e o gate history:check deve continuar PASS.
- Cada fase = 1 commit lógico por repo. Nada de misturar WIP antigo.
- Saída enxuta: você sempre entrega no formato “Implementação Concluída” (policy aplicada, artefatos, docs, gates, próximos passos).

ESTADO ATUAL (O QUE JÁ EXISTE)

A) govevia-site — ENTREGUE (PASS)
A1) Brand/CSP hygiene:
- Assets de marca versionados (*.v2.svg), sem <text> e sem dependência de fonte/URL externa.
- Evidências e docs de brand + report de “no external urls”.
A2) Fase 1 (DB base):
- lib/db/schema.sql (idempotente + pgcrypto)
- lib/db/postgres.ts (Pool singleton via globalThis + dbQuery/dbTransaction tipados)
- lint/build PASS
A3) Fase 2 (Admin Auth):
- lib/auth/admin.ts + middleware.ts protegendo /admin (JWT HS256, cookie HttpOnly)
- /admin/login, /admin/logout, /admin (force-dynamic)
- POL-ADMIN-ACCESS + runbooks + evidência
- gates PASS (lint/build/tokens:check/security:csp)
A4) Gate de histórico:
- scripts/verify-changelog-updated.mjs (history:check) endurecido p/ CI/PR (merge-base origin/main)
- Evidência + manifesto atualizado
A5) Conteúdo (ETAPA 3.1):
- lib/db/content.ts (content_entries + content_revisions, upsert transacional)
- lib/content/getContent.ts (server-only, published-only, timeout curto, fallback seguro)
- gates PASS
A6) UI Admin Conteúdo (ETAPA 3.2):
- /admin/content (listagem+busca)
- /admin/content/[id] (edição + revisões + server actions + sanitização hard-rule)
- CHANGELOG atualizado; gates PASS

B) govevia (Core) — ENTREGUE PARCIAL
B1) FASE A (Contrato):
- docs/contracts/openapi/govevia-service-api.v1.yaml (OpenAPI 3.1 SSOT)
- POL-SERVICE-API-CONTRACT + RUN-SERVICE-API-VERSIONING + evidência
- tools/openapi com gate openapi:check
- openapi:check OK
B2) ALERTA:
- test:unit do Core já estava falhando (ex.: ApplicationContext/JDBC/PasswordEncoder). Isso precisa ser tratado antes de elevar “robustez enterprise”.

CORREÇÕES EVIDENTES (CÉTICO) — APLICAR AGORA
C0) Persona page proposta com inline styles/HEX + @import Google Fonts É INACEITÁVEL (quebra tokens + CSP).
=> Qualquer implementação de /plataforma persona-driven deve ser refeita usando tokens e zero fontes externas.

OBJETIVO NOVO (INCORPORAR AO ESCOPO)
1) Criar uma API no Core para expor “implementações”, SLA, capacidade, governança, evidências operacionais — consumível pelo site.
2) No site, manter: documentação, relacionamento com clientes/distribuidores/prestadores, implantação 100% online.
3) No site, incluir módulo de Marca + controle do Registro INPI (processo, classe, status, prazos, documentos).
4) Criar “barra de tempo / timeline” para eu acompanhar andamento (deploys, commits, gates, edições de conteúdo), com mínimo consumo de tokens e auditabilidade.
5) Definir um modelo comum de nomenclatura entre ferramentas (commits, branches, artefatos, keys CMS, endpoints, eventos).

PLANO DE IMPLEMENTAÇÃO (FASES INEQUÍVOCAS)

FASE B (CORE) — “Service Status Read API” + estabilização mínima de testes
B-01) Corrigir baseline do Core para que test:unit volte a PASS (sem relaxar qualidade). Se for falha estrutural de contexto, criar correção mínima e evidência.
B-02) Evoluir OpenAPI v1 com endpoints READ-ONLY:
- GET /v1/status (health lógico com versão do contrato)
- GET /v1/capabilities (lista capacidades, eixos, status: planned/implemented/disabled)
- GET /v1/sla (SLA por módulo/serviço)
- GET /v1/governance/gates (últimos resultados/gates)
- GET /v1/releases (versão + commit + changelog hash)
B-03) Auth server-to-server simples e robusta:
- HMAC assinada (X-Govevia-Signature + timestamp) OU token estático rotacionável (ENV), documentado em policy/runbook.
B-04) Evidência + policy + runbook + registro no manifesto.
B-05) Gate: openapi:check continua obrigatório; testes PASS.

FASE C (SITE) — Core API Client (server-only) + cache + fallback
C-01) Criar lib/core-api/client.ts (server-only):
- chama Core API com timeout, retry mínimo, e fallback seguro (não quebra render).
- caching por request (React cache) + revalidate controlado.
C-02) ENV:
- GOVEVIA_CORE_API_BASE_URL
- GOVEVIA_CORE_API_AUTH_SECRET (ou token/hmac secret)
C-03) Evidência + runbook “como configurar integração”.

FASE D (SITE) — Timeline de andamento (barra de tempo) + ingestão auditável
D-01) Criar schema no Postgres do site:
- activity_events (tipo, fonte, actor, payload resumido, created_at)
- deployment_events (commit_sha, branch, environment, status, created_at)
- gate_runs (gate_id, result, evidence_ref, created_at)
D-02) Criar endpoint interno (API route) para CI registrar eventos:
- /api/internal/ingest (assinado por secret, fail-closed)
D-03) UI Admin:
- /admin/activity (timeline com filtros: conteúdo, deploy, gates, integrações)
- deve ser leve e incremental (paginação).
D-04) Evidência + policy (POL-ACTIVITY-LOGGING) + runbook.

FASE E (SITE) — Módulo Marca + INPI (controle completo)
E-01) Schema:
- brands (EnvNeo, Govevia)
- trademark_records (marca, classe Nice, número processo, status, datas, documentos)
- trademark_events (timeline de movimentações)
E-02) UI Admin:
- /admin/brand (dados da marca: assets, uso, disclaimers)
- /admin/inpi (cadastro + status + prazos + anexos + timeline)
E-03) Conteúdo público:
- chaves CMS para “EnvNeo é PJ / Govevia é marca”, rodapés, disclaimers e página institucional.
E-04) Evidência + policy (POL-BRAND-INPI) + runbook (RUN-INPI-OPERATIONS).

FASE F (SITE) — Personas + /plataforma (compliance total)
F-01) Refazer /plataforma persona-driven SEM HEX e SEM fontes externas.
- usar tokens/classes existentes
- dados canônicos (capabilities/eixos/personas) devem vir do Core API quando possível; o resto do texto via CMS (getContent).
F-02) CTAs por persona (texto via CMS) e matriz renderizada.
F-03) Gates PASS.

FASE G (PADRÃO COMUM DE NOMENCLATURA) — Core + Site
G-01) Criar docs/standards/NAMING-CONVENTIONS.md (em ambos repos) contendo:
- Conventional Commits (feat/fix/docs/chore), escopo (site|core|admin|policy|runbook|openapi)
- IDs de artefatos: POL-*, RUN-*, REPORT-*
- Keys CMS: dominio.secao.item (ex: plataforma.capability.alertas.desc)
- Endpoints: /v1/<resource> (kebab-case)
- Eventos: <domain>.<entity>.<action> (ex: portal.content.updated)
G-02) Atualizar manifestos de governança para registrar esse standard.

REGRAS PARA REDUZIR TOKENS (EFICIÊNCIA)
- Em cada fase: toque no mínimo de arquivos; não reimprima código inteiro.
- Sempre reporte: (1) arquivos, (2) trechos críticos de diff, (3) comandos/gates e resultado.
- Nunca repetir explicações longas; usar bullets.
- Qualquer coisa que quebre CSP/tokens/HEX deve ser revertida imediatamente (gate é autoridade).

EXECUÇÃO
Agora execute SOMENTE a próxima fase pendente, na ordem:
- Se o Core ainda não tiver test:unit PASS, comece por B-01 e pare quando fechar.
Ao final, entregue “Implementação Concluída” e PARE para validação.
FIM DO PROMPT
